// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: competition.sql

package db

import (
	"context"
)

const createCompetition = `-- name: CreateCompetition :one
INSERT INTO competitions (
  challenger_id,
  rival_id,
  challenge_id,
  status
) VALUES (
  $1, $2, $3, $4
) RETURNING id, challenger_id, rival_id, challenge_id, status, created_at, updated_at
`

type CreateCompetitionParams struct {
	ChallengerID int64  `json:"challenger_id"`
	RivalID      int64  `json:"rival_id"`
	ChallengeID  int64  `json:"challenge_id"`
	Status       string `json:"status"`
}

func (q *Queries) CreateCompetition(ctx context.Context, arg CreateCompetitionParams) (Competition, error) {
	row := q.db.QueryRowContext(ctx, createCompetition,
		arg.ChallengerID,
		arg.RivalID,
		arg.ChallengeID,
		arg.Status,
	)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.ChallengerID,
		&i.RivalID,
		&i.ChallengeID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompetition = `-- name: GetCompetition :one
SELECT id, challenger_id, rival_id, challenge_id, status, created_at, updated_at FROM competitions WHERE id = $1
`

func (q *Queries) GetCompetition(ctx context.Context, id int64) (Competition, error) {
	row := q.db.QueryRowContext(ctx, getCompetition, id)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.ChallengerID,
		&i.RivalID,
		&i.ChallengeID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompetitionsByChallenge = `-- name: GetCompetitionsByChallenge :many
SELECT id, challenger_id, rival_id, challenge_id, status, created_at, updated_at FROM competitions WHERE challenge_id = $1
`

func (q *Queries) GetCompetitionsByChallenge(ctx context.Context, challengeID int64) ([]Competition, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitionsByChallenge, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Competition
	for rows.Next() {
		var i Competition
		if err := rows.Scan(
			&i.ID,
			&i.ChallengerID,
			&i.RivalID,
			&i.ChallengeID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompetitionsByUser = `-- name: GetCompetitionsByUser :many
SELECT id, challenger_id, rival_id, challenge_id, status, created_at, updated_at FROM competitions WHERE challenger_id = $1
`

func (q *Queries) GetCompetitionsByUser(ctx context.Context, challengerID int64) ([]Competition, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitionsByUser, challengerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Competition
	for rows.Next() {
		var i Competition
		if err := rows.Scan(
			&i.ID,
			&i.ChallengerID,
			&i.RivalID,
			&i.ChallengeID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompetitionsByUserAndChallenge = `-- name: GetCompetitionsByUserAndChallenge :one
SELECT id, challenger_id, rival_id, challenge_id, status, created_at, updated_at FROM competitions WHERE challenger_id = $1 AND rival_id = $2 AND challenge_id = $3 LIMIT 1
`

type GetCompetitionsByUserAndChallengeParams struct {
	ChallengerID int64 `json:"challenger_id"`
	RivalID      int64 `json:"rival_id"`
	ChallengeID  int64 `json:"challenge_id"`
}

func (q *Queries) GetCompetitionsByUserAndChallenge(ctx context.Context, arg GetCompetitionsByUserAndChallengeParams) (Competition, error) {
	row := q.db.QueryRowContext(ctx, getCompetitionsByUserAndChallenge, arg.ChallengerID, arg.RivalID, arg.ChallengeID)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.ChallengerID,
		&i.RivalID,
		&i.ChallengeID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
